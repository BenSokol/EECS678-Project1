The quash shell we built attempts to mimic bash while still fulfilling the required features as listed in the project page.
We first tokenize the input for keywords, and pipes, and use the tokens to receive the command and its args to execute.

(1) Run executables without arguments.
    Running executables without arguments is done mainly within QUASH_tokenizer, QUASH_process, and QUASH_main.
    Running "ls" for example, will list the files and folders within the current working directory.
    Within QUASH_process, if the executable, located in the first token from the tokenizer, is not a key word (such as cd or kill), then it will create a fork
    and run that executable in a child process, while the parent waits for the child process to finish.

(2) Run executables with arguments.
    Running executables with arguments is done mainly within QUASH_tokenizer, QUASH_process, and QUASH_main.
    Running "ls" + directory name, will list the files within that directory.
    Within QUASH_process, if the executable, located in the first token from the tokenizer, is not a key word (such as cd or kill), then it will create a fork
    and run that executable in a child process, while the parent waits for the child process to finish. The arguments for that executable will be located in the later
    tokens and executed along with the executable within the execvpe call.

(3) set for HOME and PATH work properly

(4) exit and quit work properly
    Running "exit" or "quit" will exit QUASH as expected. This is done similar to running executables without arguments, however instead of executing anything, a
    signal is passed into QUASH_main and main handles that signal to exit QUASH.

(5) cd (with and without arguments) works properly
    cd changes the pwd (present working directory). This is done mostly within QUASH_cd and QUASH_pwd. When there are no arguments to cd, the HOME directory is used
    and the pwd is changed to that. When there are arguments to cd, we search the pwd and move to that directory if it is present. We utilize the chdir() function to
    perform the actual change.

(6) PATH works properly. Give error messages when the executable is not found
    Given a PATH, Quash should make sure that the executable is present either within the PATH or in the local directory and give an error if it is in neither.
    Within QUASH_process, using the std::filesystem class, we search if the executable is in the PATH before running it, and it will return an error if it does not exist.

(7) Child processes inherit the environment
    Using the fork() command, the child process will receive the environment of the parent when running its process.

(8) Allow background/foreground execution (&)
    When creating a process, we check to see if we run the process asynchronously (foreground), or in the background. If it is to be run in the background, we create a thread to
    run the process and add it to a list of "processes". We check this list of processes using "jobs" to see if the process is still running in the background or it is finished.
    If it is finished, it gets removed from the list of processes.

(9) Printing/reporting of background processes, (including the jobs command)
    Using the "jobs" command, we see the list of current background processes. When a background process finishes, we report that to the screen when the next command (or just enter) is entered.
    When starting a background process, we list the one that is starting along with the ones that are currently running.
    This is done mostly in QUASH_process and QUASH_main using the checkJobStatus function.

(10) Allow file redirection (> and <)

(11) Allow (1) pipe (|)
     Within QUASH_process, we check the tokens returned from the tokenizer to see if there is a "|" listed within. If so, we create a pipe, and this pipe is put onto a list of pipes (in case we have multiple).
     We then take the currentCommand (all the tokens up to the "|"), and run that while we pipe the output from that into the input of the next one.
     For example, "ls | less", should work as intended.

(12) Supports reading commands from prompt and from file

(13) Support multiple pipes in one command.
     Using the logic from QUASH_process, multiple pipes should be supported, however, it has not been fully tested yet.

(14) kill command delivers signals to background processes. The kill command has the format:
kill SIGNUM JOBID, where SIGNUM is an integer specifying the signal number, and JOBID
is an integer that specifies the job that should receive the signal.

      Kill is handled in QUASH_process. We check to see if the jobid given in within the scope of our list of processes, and if so, we send the signal to that process.
      It then stops the process and deletes it from the list of processes.
      "kill 2 9" kills the second process running in the background.

For testing, we used a test suite which can be run using "make test", as well as testing code as we implemented it.
